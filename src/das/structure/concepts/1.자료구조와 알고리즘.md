### 자료구조 (Data Structure) 와 알고리즘 (Algorithm)

#### **1. 기본 개념**

*   **자료 (Data)**: 컴퓨터가 처리할 수 있는 모든 것.
*   **자료구조 (Data Structure)**: 여러 자료(Data)들을 특정 구조에 따라 담아두고, 이에 적용할 연산(Operation)들을 함께 정의한 것. 즉, `(데이터의 묶음 + 허용된 연산)`의 집합.
*   **알고리즘 (Algorithm)**: 특정 자료구조에 담긴 입력을 받아, 정해진 논리적 절차(연산)를 따라 문제를 해결하고 정답을 도출하는 방법.

#### **2. 자료구조의 예시**

##### **1) 변수 (Variable)**

*   가장 단순한 형태의 자료구조. 하나의 데이터를 저장하기 위해 특정 메모리 공간을 할당하고, 그 공간을 가리키는 이름을 부여한 것.
*   **쓰기**: `int a = 5;` // 이름이 'a'인 메모리 공간에 5를 저장
*   **읽기**: `System.out.println(a);` // 이름이 'a'인 공간의 값을 읽어옴

> 변수가 자료구조인 이유는, 단순히 값을 담는 것을 넘어, 할당된 '메모리 공간(Data)'과 그 공간에 값을 '쓰고 읽는 연산(Operation)'이 결합된 구조이기 때문.

##### **2) 배열 (Array)**

*   같은 타입의 데이터 여러 개를 연속된 메모리 공간에 순서대로 저장하는 자료구조.
*   각 데이터는 고유한 인덱스(index)를 통해 직접 접근 가능.
*   `int[] A = {3, -1, 5, 7};`

*   **접근/읽기**: `int value = A[2];` // value 변수에 5가 저장됨.
*   **쓰기**: `A[3] = 10;` // 배열 A는 {3, -1, 5, 10}이 됨.

*   **삽입/삭제 (고정 배열의 한계)**:
    *   Java의 기본 배열(`int[]`)은 크기가 고정되어 있어 직접적인 삽입(`insert`)이나 삭제(`pop`) 메소드를 제공하지 않음.
    *   이러한 기능을 구현하려면, 더 큰 새 배열을 만들고 기존 요소들을 직접 복사하는 복잡한 과정을 거쳐야 함.
*   **예시: 2번 인덱스에 99를 삽입하는 경우**
    ```
    int[] B = new int[A.length + 1]; // 기존보다 1칸 큰 배열 생성
    for (int i = 0; i < 2; i++) {
        B[i] = A[i]; // 2번 인덱스 전까지 복사
    }
    B[2] = 99; // 새 값 삽입
    for (int i = 2; i < A.length; i++) {
        B[i + 1] = A[i]; // 나머지 값들을 뒤로 밀어서 복사
    }   
    // B는 {3, -1, 99, 5, 10}이 됨
    ```
    > 단, 자바에서는 기본 배열의 삽입/삭제가 비효율적이므로, 크기가 동적으로 변하는 `ArrayList` 같은 컬렉션 자료구조를 사용하는 것이 일반적

#### **3. 알고리즘의 예시: 최대공약수(GCD) 계산**

두 정수 `a`와 `b`의 공약수 중 가장 큰 값을 찾는 문제. 유클리드 호제법이 대표적.

##### **1) 뺄셈을 이용한 구현 (비효율적)**

*   **논리**: `GCD(a,b)`는 `GCD(a-b, b)`와 같다는 원리를 반복. 큰 수에서 작은 수를 계속 빼서 두 수를 같게 만들면 그 수가 GCD.
*   **코드**:
    ```java
    public int gcd_sub(int a, int b) {
      while(a != b) { // a와 b가 같아질 때까지 반복
          if (a > b) {
              a = a - b;
          } else {
              b = b - a;
          }
      }
      return a; // 또는 b, 어차피 같음
    }
    ```
*   **문제점**: `gcd(100, 2)`를 구하려면 `100-2`, `98-2`, ... 와 같이 뺄셈을 49번 반복해야 함. 매우 구림.

##### **2) 나머지(%) 연산을 이용한 구현 (효율적)**

*   **논리**: 여러 번의 뺄셈은 나눗셈의 나머지(결국 몫으로 빼기를 반복하고 나머지를 구한 것이니)를 구하는 과정과 동일. 따라서 나머지 연산(`%`)을 사용하면 빠르다!
*   **핵심 원리**: `GCD(a, b)`는 `GCD(b, a % b)`와 같다.
*   **코드 (반복문)**:
    ```java
    public int gcd_mod(int a, int b) {
      while(b != 0) { // b가 0이 될 때까지 반복
          int temp = a % b;
          a = b;
          b = temp;
      }
      return a; // b가 0이 되었을 때의 a값이 GCD
    }
    ```
*   **장점**: `gcd(100, 2)`의 경우 `100 % 2 = 0` 이므로, 단 한 번의 연산만으로 `b`가 `0`이 되어 알고리즘이 종료됨.

##### **3) 재귀(Recursive)를 이용한 구현**

*   **논리**: 유클리드 호제법의 원리 `GCD(a, b) = GCD(b, a % b)` 자체를 코드로 표현. 함수가 자기 자신을 다시 호출하는 방식.
*   **코드 (재귀)**:
    ```java
    public int gcd_rec(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd_rec(b, a % b); // b가 0이 될 때까지 재귀 호출
    }
    ```
*   **특징**: 코드가 수학적 정의와 유사해서 매우 간결하고 직관적이라고 한다. 내부적으로는 반복문 방식과 동일하게 동작.

##### 내가 이해한 유클리드 호제법

최대공약수는 '두 수의 공약수는 특정 연산을 반복해도 그대로 유지된다'는 성질을 이용해 구한다. 수학적 증명은 각설하고 핵심은 다음 두 가지인 듯

*   **빼기 연산**: 두 수가 있으면 큰 수에서 작은 수를 뺀다. 그 다음엔, `(기존의 작은 수)`와 `(방금 뺀 결과값)`을 가지고 똑같은 짓을 두 수가 같아질 때까지 반복한다.

*   **나누기 연산**: 두 수가 있으면 큰 수를 작은 수로 나눈다. 그 다음엔, `(기존의 작은 수)`와 `(방금 나온 나머지)`를 가지고 똑같은 짓을 나머지가 0이 될 때까지 반복한다. 이 방식은 빼기 과정의 결과값을 구할 때, 여러 번 빼야 할 과정을 나눗셈 한 번으로 건너뛰는 거라 훨씬 빠르다.

또한, 나누기 방식을 반복문으로 짜든 재귀 함수로 짜든 결과는 똑같다.

> 핵심은, 같은 문제를 해결하더라도 어떤 알고리즘을 선택하는가에 따라 성능(속도, 메모리 사용량 등)이 크게 달라질 수 있다는 것.
