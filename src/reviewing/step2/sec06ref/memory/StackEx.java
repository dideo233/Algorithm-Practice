package reviewing.step2.sec06ref.memory;

public class StackEx {

    /**
     * 1. 자바 메모리 구조 개요
     * - 자바는 OS로부터 메모리를 할당받아 3가지 주요 영역으로 나누어 관리함.
     * - 메서드(Method), 스택(Stack), 힙(Heap) 영역.
     *
     * 2. 메서드 영역 (Method Area)
     * - "클래스 레벨"의 정보가 저장되는 공통 영역.
     * - 프로그램 시작 시 로딩되고 종료 시까지 유지됨 (가장 긴 생명 주기).
     * - 보관 내용:
     *   1) 클래스 정보: 실행 코드(바이트 코드), 필드, 메서드, 생성자 등의 명세(설계도).
     *   2) Static 영역: static 변수(정적 변수/클래스 변수)가 보관됨.
     *   3) 런타임 상수 풀: 공통 리터럴 상수, String 리터럴 등이 저장됨.
     * - 특징: 인스턴스가 없어도 접근 가능하며, 모든 쓰레드가 공유함.
     *
     * 3. 스택 영역 (Stack Area)
     * - 실제 프로그램의 "실행 흐름"을 담당하는 영역.
     * - 구조: LIFO (Last In First Out, 후입선출).
     *   -> 나중에 들어온 게 먼저 나가는 구조 (큐(Queue/FIFO)와 반대).
     * - 작동 방식:
     *   1) 메서드 호출 시 '스택 프레임(Stack Frame)'이라는 블록이 하나씩 생성(Push).
     *   2) 프레임 내부에는 '지역 변수', 매개변수, 연산 결과, 호출 정보가 저장됨.
     *   3) 메서드 종료 시 해당 프레임은 즉시 제거(Pop)됨.
     * - 특징: 각 쓰레드별로 별도의 스택이 생성됨. (스택 프레임이 모두 사라지면 프로그램 종료).
     *
     * 4. 힙 영역 (Heap Area)
     * - 객체(인스턴스)와 배열이 생성되는 실제 데이터 저장소.
     * - 작동 방식:
     *   1) `new` 명령어가 실행되면 무조건 여기에 객체가 생성됨.
     *   2) 스택 영역의 변수는 힙 영역에 생성된 객체의 '참조값(주소)'을 가짐.
     * - 관리: 가비지 컬렉션(GC)의 주요 대상.
     *   -> 스택에서 더 이상 참조하지 않는(끊어진) 객체는 GC가 자동으로 제거함.
     *
     * 5. 스택과 힙의 상호작용 (실행 흐름 예시)
     * - 시나리오: `main()` -> `method1()` -> `new Data()` 생성.
     * - 순서:
     *   1) `main` 실행: 스택에 메인 프레임 생성.
     *   2) `method1` 호출: 스택에 method1 프레임 생성.
     *   3) `new Data()` 실행: 힙 영역에 Data 객체 생성.
     *   4) 변수 연결: method1 프레임 내부의 지역 변수(참조 변수)가 힙 영역의 Data 객체 주소를 저장.
     *   5) `method1` 종료: 스택 프레임 제거 -> 지역 변수 소멸 -> 힙 영역 객체를 가리키는 참조가 사라짐.
     *   6) GC 발생: 참조가 끊긴 힙 영역의 Data 객체를 메모리에서 해제.
     *
     * 6. 변수의 종류와 생명 주기 (Scope & Lifecycle)
     * - 변수가 어디에 선언되었느냐에 따라 저장 위치와 생존 기간이 결정됨.
     *
     * -  클래스 변수 (Static Variable)
     *    - 위치: 메서드 영역 (Static 영역).
     *    - 생명 주기: 프로그램 시작(클래스 로딩) ~ 프로그램 종료. (가장 김)
     *    - 특징: 객체 생성 없이 `클래스명.변수명`으로 접근. 모든 곳에서 공유.
     *
     * -  인스턴스 변수 (Instance Variable)
     *    - 위치: 힙 영역 (객체 내부).
     *    - 생명 주기: 객체 생성(`new`) ~ GC에 의해 수거될 때까지.
     *    - 특징: 객체를 생성해야만 접근 가능. 인스턴스마다 별도의 값을 가짐.
     *
     * - 지역 변수 (Local Variable)
     *    - 위치: 스택 영역 (스택 프레임 내부).
     *    - 생명 주기: 메서드 호출 ~ 메서드 종료. (가장 짧음)
     *    - 특징: 해당 메서드 블록 내부에서만 유효함.
     *
     * 7. Static 메서드 (정적 메서드)
     * - 인스턴스 생성 없이 클래스 자체에서 호출 가능한 메서드.
     * - 대표 예시: `main()` 메서드 (프로그램 시작점이라 객체 생성 전 실행되어야 함).
     * - 제약 사항:
     *   1) Static 메서드 내부에서는 인스턴스 변수나 인스턴스 메서드를 사용할 수 없음.
     *      (이유: Static이 실행되는 시점에 인스턴스가 생성되어 있다는 보장이 없기 때문).
     *   2) Static 메서드는 오직 Static 변수나 다른 Static 메서드만 호출 가능.
     * - 활용: 유틸리티성 메서드, 공용 함수 등 객체의 상태(변수)와 무관한 기능을 만들 때 사용.
     */

    public static void main(String[] args){
        //스택의 순서는 다음 실행 순서를 따름
        System.out.println("main start");
        method1(10);
        System.out.println("main end");
    }

    static void method1(int m1) {
        System.out.println("method1 start");
        int cal = m1 * 2;
        method2(cal);
        System.out.println("method1 end");
    }

    static void method2(int m2) {
        System.out.println("method2 start");
        System.out.println("method2 end");
    }
}