## 역할과 구현의 분리

**[전제]** 

보통 객체 지향의 장점으로 '유연함, 변경 용이' 등을 꼽는다.

**[해설]**

1. 객체지향의 핵심 시각: "역할(Role)과 구현(Implementation)의 분리"
- 세상을 '역할'과 '구현'으로 구분한다.
- 예: 운전자(클라이언트)는 자동차의 역할(엑셀, 브레이크)만 알면, 실제 차종(구현)이 아반떼든 테슬라든 상관없이 운전할 수 있다.

2. 자바 언어의 적용
- 역할 = 인터페이스 (Interface)
- 구현 = 구현 클래스 (Class)
- [핵심] 객체 설계 시 '역할(인터페이스)'을 먼저 부여하고, 나중에 '구현(클래스)'을 만든다.

3. 왜 유연해지는가? (작동 원리)
- 역할과 구현을 분리했기 때문에, 클라이언트는 복잡한 '구현(클래스)'을 몰라도 된다.
- 클라이언트는 오직 '역할(인터페이스)'하고만 대화(의존)하면 된다. (DIP, 의존관계 역전 원칙)
  > 이때 자바의 다형성(오버라이딩) 덕분에, 인터페이스를 호출해도 실제로는 구현 객체의 메서드가 실행된다.

4. 다형성의 본질
- 인터페이스를 구현한 객체라면, 다른 객체로 실행 시점에 유연하게 변경할 수 있다. 
- 클라이언트는 구체적인 대상(지금 어떤 객체를 참조하는지)을 몰라도 된다.
  > "클라이언트 코드를 변경하지 않고, 서버의 기능을 무한히 확장할 수 있다."

5. 한계와 주의점
- 인터페이스(역할) 자체가 변하면, 클라이언트와 서버 모두 큰 변경이 필요하다.
- 따라서 인터페이스를 안정적으로(변하지 않게) 설계하는 것이 가장 중요하다.

6. 다형성을 사용하지 않을 때 발생하는 기술적 문제
- 구현 클래스와의 강한 결합 (Tight Coupling)
  - 인터페이스(역할)가 아닌 구체적인 클래스(구현)를 변수 타입으로 사용하면, 클라이언트 코드가 해당 구현 클래스를 직접 의존하게 된다.
  - 결과적으로 구현체를 교체해야 할 때, 이를 참조하고 있는 클라이언트의 코드(타입 선언부, 생성 로직 등)까지 모두 뜯어고쳐야 하는 연쇄적인 수정이 발생한다.
- 확장 시 비즈니스 로직 수정 불가피 (If-Else 지옥)
  - 다형성(메서드 오버라이딩)에 기반한 호출이 불가능하므로, 클라이언트는 각 구현체별로 다른 동작을 수행하기 위해 if-else나 switch 같은 조건문을 비즈니스 로직에 직접 작성해야 한다.
  - 기능 하나를 추가할 때마다 기존 핵심 로직의 분기문을 열어서 코드를 수정해야 하므로, 실수를 유발하기 쉽고 유지보수가 매우 어려워진다.

**[결론]**

- 역할과 구현의 분리는 다형성이 가장 핵심이다.
- 다형성을 제대로 이해해야 역할 변경 없이 기능을 확장하는 유연한 설계를 할 수 있다.
- 스프링(Spring)의 핵심 기술(IoC, DI)이나 디자인 패턴 대부분도 결국 다형성을 활용하는 것.

**[용어 정리]**

객체지향에서의 클라이언트와 서버는 네트워크(웹)가 아니라 '객체 간의 협력 관계'를 의미한다.
- 클라이언트(Client): 기능을 요청(호출)하는 대상. (예: 운전자, main 메서드)
- 서버(Server): 기능을 제공(수행)하는 대상. (예: 자동차, Animal 구현체)

## 개방 폐쇄 원칙 (OCP, Open-Closed Principle) 원칙

소프트웨어는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.

**[확장에 열려 있다]**

새로운 기능을 추가할 때 기존 코드를 건드리지 않고 확장할 수 있다는 의미다.

예를 들어 Seperate 예제에서 NewCar를 추가해도 Driver 클래스는 전혀 수정할 필요가 없다. Car 인터페이스를 구현하기만 하면 새로운 차량을 얼마든지 추가할 수 있다. 이것이 확장에 열려 있다는 것이다.

**[변경에 닫혀 있다]**

기존에 잘 동작하던 코드는 수정하지 않는다는 의미다.

- 변하지 않는 부분: Driver가 Car 인터페이스에만 의존하기 때문에, 어떤 차량이 추가되든 Driver의 핵심 로직은 변하지 않는다. (클라이언트 부분)
- 변하는 부분: 물론 새 차량 객체를 생성하고 주입하는 코드는 추가된다.
 
핵심은 클라이언트의 비지니스 로직은 그대로 유지된다는 점이다. 

**[전략 패턴과의 관계]**

- 전략 패턴
  - 실행 중에 알고리즘(전략)을 선택해서 바꿔 끼울 수 있게 만드는 디자인 패턴
  - "어떻게 할지"를 정하는 부분을 인터페이스로 분리해서, 상황에 따라 다른 방식으로 동작하게 만듬
  - OCP 원칙을 실현하는 대표적인 디자인 패턴

- Seperate 패키지 예제 
  - Car 인터페이스 = 전략 인터페이스
  - K3Car, Model3Car 등 = 구체적인 전략 구현체
  - Driver = 전략을 사용하는 클라이언트